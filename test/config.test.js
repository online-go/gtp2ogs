// vim: tw=120 softtabstop=4 shiftwidth=4

const assert = require('assert');

const { getNewArgvWithArguments } = require('./module_loading/getNewArgvWithArguments');
const { getNewConfigUncached } = require('./module_loading/getNewConfigUncached');
const { stub_console } = require('./utils/stub_console');

let argv;
let config;

describe('Config', () => {
   
    beforeEach(function() {
        stub_console();

        argv = getNewArgvWithArguments();
        config = getNewConfigUncached();
    });

    describe('Dropped Options', () => {
        it('throw error if dropped option that has a new alternative is used (ex: boardsize)', () => {
            argv.boardsize = "9,13,19";
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if dropped option that does not have a new alternative is used (ex: fakerank)', () => {
            argv.fakerank = "5d";
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if dropped option that has an alternative generated by a function is used (ex: minmaintime + blitz + ranked)', () => {
            argv.minmaintime = 300;
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw error if a supported option is used (ex: timeout)', () => {
            argv.timeout = 5;
            
            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });
    });

    describe('General ranked unranked options export rules', () => {
        // TODO rewrite this after PR #320 is merged (do not leak general arg out of config)

        // here using the example of minmaintimeblitz

        it('throw error if general arg is used with ranked arg', () => {
            argv.minmaintimeblitz = 9;
            argv.minmaintimeblitzranked = 7;
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if general arg is used with unranked arg', () => {
            argv.minmaintimeblitz = 9;
            argv.minmaintimeblitzunranked = 11;
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw error if ranked arg is used with unranked arg', () => {
            argv.minmaintimeblitzranked = 7;
            argv.minmaintimeblitzunranked = 11;
            
            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw error if no arg is used', () => {           
            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

        it('export only general arg default if no arg is used and option has a default (ex: minmaintimeblitz)', () => {
            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmaintimeblitz, 15);
            assert.deepEqual(config.minmaintimeblitzranked, undefined);
            assert.deepEqual(config.minmaintimeblitzunranked, undefined);
        });

        it('do not export anything if no arg is used and option has no default (ex: minrank)', () => {
            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmrank, undefined);
            assert.deepEqual(config.minmrankranked, undefined);
            assert.deepEqual(config.minmrankunranked, undefined);
        });

        it('export only general arg if used', () => {
            argv.minmaintimeblitz = 9;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmaintimeblitz, 9);
            assert.deepEqual(config.minmaintimeblitzranked, undefined);
            assert.deepEqual(config.minmaintimeblitzunranked, undefined);
        });

        it('export ranked arg if only ranked arg is used, and for unranked arg export default', () => {
            argv.minmaintimeblitzranked = 7;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmaintimeblitz, undefined);
            assert.deepEqual(config.minmaintimeblitzranked, 7);
            assert.deepEqual(config.minmaintimeblitzunranked, 15);
        });

        it('export unranked arg if only unranked arg is used, and for ranked arg export default', () => {
            argv.minmaintimeblitzunranked = 11;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmaintimeblitz, undefined);
            assert.deepEqual(config.minmaintimeblitzranked, 15);
            assert.deepEqual(config.minmaintimeblitzunranked, 11);
        });

        it('export only ranked arg and unranked arg if both are used (do not use default)', () => {
            argv.minmaintimeblitzranked = 7;
            argv.minmaintimeblitzunranked = 11;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minmaintimeblitz, undefined);
            assert.deepEqual(config.minmaintimeblitzranked, 7);
            assert.deepEqual(config.minmaintimeblitzunranked, 11);
        });

    });

    describe('Debug', () => {

        it('export debug', () => {
            argv.debug = true;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.debug, true);
        });

        it('export DEBUG if debug is used', () => {
            argv.debug = true;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.DEBUG, true);
        });

        it('do not export debug if not used', () => {
            // default is enabled in tests argv generator, manually disable it
            argv.debug = undefined;

            config.updateFromArgv(argv);

            assert.deepEqual(config.debug, undefined);
        });

        it('do not export DEBUG if not used', () => {
            // assignConfigArguments would assing config.DEBUG to be true regardless of argv's debug,
            // so we now assignConfigArguments out of the getNewConfig functions, and we never
            // assignConfigArguments in config.test.js because testing if argv is correctly exported
            // is the purpose of this test, there is not point to assign config.DEBUG before testing
            // config.updateFromArgv(argv)
            argv.debug = undefined;

            config.updateFromArgv(argv);

            assert.deepEqual(config.DEBUG, undefined);
        });

    });

    describe('Microseconds: timeout and startupbuffer', () => {

        it('export timeout multiplied by 1000', () => {
            argv.timeout = 5;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.timeout, 5000);
        });

        it('export startupbuffer multiplied by 1000', () => {
            argv.startupbuffer = 5;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.startupbuffer, 5000);
        });

    });

    describe('Logfile', () => {

        it('export logfile filename string without change if valid', () => {
            argv.logfile = "some-filename";

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.logfile, "some-filename");
        });

        it('export fixed logfile filename if invalid string filename', () => {
            argv.logfile = "*/\\_some-file#<>$!&*'{?\"}:name 9876543210AZaz@+|=,;._!?==`file-";

            config.updateFromArgv(argv);

            assert.deepEqual(config.logfile, "---_some-file-------------name 9876543210AZaz------._-----file-");
        });

        it('export logfile with default filename based on current date and time if empty string (--logfile)', () => {
            argv.logfile = "";
            // - month is between 0 and 11 (add +1)
            // - Date.UTC in this local test to avoid local GMT mismatch between expected and result,
            //   that varies between testing machines, but local time is fine in the real gtp2ogs.
            //   ex: GMT+2 on this local machine would make 0 (hours) AM GMT +2 become 22 (hours) PM
            //   of the previous day.
            //   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC
            config.start_date = new Date(Date.UTC(2020, 6, 10, 8, 30, 45, 333));

            config.updateFromArgv(argv);

            assert.deepEqual(config.logfile, "gtp2ogs-logfile-2020-07-10T08-30-45.333Z");
        });

        it('export logfile filename as a string without change if all characters are valid and are numbers', () => {
            argv.logfile = "333333333";
            config.start_date = new Date(Date.UTC(2020, 6, 10, 8, 30, 45, 333));

            config.updateFromArgv(argv);

            assert.deepEqual(config.logfile, "333333333");
        });

        it('do not export logfile if not used', () => {
            config.updateFromArgv(argv);
            
            assert.deepEqual(config.logfile, undefined);
        });

    });

    describe('Ogspv AIs', () => {

        it('supported Ogspv AI LEELAZERO is exported', () => {
            argv.ogspv = "LEELAZERO";

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.ogspv, "LEELAZERO");
        });

        it('supported Ogspv AI SAI is exported', () => {
            argv.ogspv = "SAI";

            config.updateFromArgv(argv);
        
            assert.deepEqual(config.ogspv, "SAI");
        });

        it('supported Ogspv AI KATAGO is exported', () => {
            argv.ogspv = "KATAGO";

            config.updateFromArgv(argv);
        
            assert.deepEqual(config.ogspv, "KATAGO");
        });

        it('supported Ogspv AI PHOENIXGO is exported', () => {
            argv.ogspv = "PHOENIXGO";

            config.updateFromArgv(argv);
        
            assert.deepEqual(config.ogspv, "PHOENIXGO");
        });

        it('do not export ogspv if not used', () => {
            config.updateFromArgv(argv);
        
            assert.deepEqual(config.ogspv, undefined);
        });

        it('supported Ogspv AI non-uppercase is exported as uppercase (ex: leelazero)', () => {
            argv.ogspv = "leelazero";

            config.updateFromArgv(argv);
        
            assert.deepEqual(config.ogspv, "LEELAZERO");
        });

        it('throw error if non-supported Ogspv AI is used (ex: AQ)', () => {
            argv.ogspv = "AQ";

            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if supported Ogspv AI is used with non-strict equal name (ex: LEELAZERO20B)', () => {
            argv.ogspv = "LEELAZERO20B";
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw error if supported Ogspv AI is used (ex: LEELAZERO)', () => {
            argv.ogspv = "LEELAZERO";
            
            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

    });

    describe('Persist Persistnoncorr', () => {

        it('export persist', () => {
            argv.persist = true;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.persist, true);
            assert.deepEqual(config.persistnoncorr, undefined);
        });

        it('do not export persist if not used', () => {
            config.updateFromArgv(argv);

            assert.deepEqual(config.persist, undefined);
            assert.deepEqual(config.persistnoncorr, undefined);
        });

        it('export persistnoncorr', () => {
            argv.persistnoncorr = true;

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.persist, undefined);
            assert.deepEqual(config.persistnoncorr, true);
        });

        it('do not export persistnoncorr if not used', () => {
            config.updateFromArgv(argv);

            assert.deepEqual(config.persist, undefined);
            assert.deepEqual(config.persistnoncorr, undefined);
        });

        it('throw an error if persist and persistnoncorr are used at the same time', () => {
            argv.persist = true;
            argv.persistnoncorr = true;

            // https://stackoverflow.com/questions/14966821/testing-for-errors-thrown-in-mocha
            // TODO: how to also check error message with mocha ?

            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw an error if persist and persistnoncorr are not used at the same time', () => {
            argv.persist = true;
            argv.persistnoncorr = undefined;

            // https://stackoverflow.com/questions/14966821/testing-for-errors-thrown-in-mocha

            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

    });

    describe('Min Rank', () => {

        it('export minrank (sdk)', () => {
            argv.minrank = "5k";

            config.updateFromArgv(argv);

            assert.deepEqual(config.minrank, 25);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('export minrank (ddk)', () => {
            argv.minrank = "13k";

            config.updateFromArgv(argv);

            assert.deepEqual(config.minrank, 17);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('export minrank (dan)', () => {
            argv.minrank = "3d";

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minrank, 32);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('export minrank (pro)', () => {
            argv.minrank = "1p";

            config.updateFromArgv(argv);
            
            assert.deepEqual(config.minrank, 37);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('throw error if invalid minrank string (ex: 1t) is used', () => {
            argv.minrank = "1t";
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if invalid minrank string (ex: empty string) is used', () => {
            // yargs enforces ranks to be of type string, make sure empty string "" is also tested
            // (not booleanly flase thus skips the test "is rank valid")

            argv.minrank = "";
            
            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not export if minrank is not used', () => {
            config.updateFromArgv(argv);

            assert.deepEqual(config.minrank, undefined);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('export minrankranked', () => {
            argv.minrankranked = "1d";

            config.updateFromArgv(argv);

            assert.deepEqual(config.minrank, undefined);
            assert.deepEqual(config.minrankranked, 30);
            assert.deepEqual(config.minrankunranked, undefined);
        });

        it('export minrankunranked', () => {
            argv.minrankunranked = "5k";

            config.updateFromArgv(argv);

            assert.deepEqual(config.minrank, undefined);
            assert.deepEqual(config.minrankranked, undefined);
            assert.deepEqual(config.minrankunranked, 25);
        });

    });

    describe('Rejectnew', () => {

        it('export rejectnew if used', () => {
            argv.rejectnew = true;

            config.updateFromArgv(argv);

            assert.deepEqual(config.rejectnew, true);
            assert.deepEqual(config.rejectnewfile, undefined);
            assert.deepEqual(config.rejectnewmsg, 'Currently, this bot is not accepting games, try again later'); // default
        });

        it('export rejectnewfile', () => {
            argv.rejectnewfile = true;

            config.updateFromArgv(argv);

            assert.deepEqual(config.rejectnew, undefined);
            assert.deepEqual(config.rejectnewfile, true);
            assert.deepEqual(config.rejectnewmsg, 'Currently, this bot is not accepting games, try again later'); // default
        });

        it('export rejectnewmsg default if not used', () => {
            config.updateFromArgv(argv);

            assert.deepEqual(config.rejectnew, undefined);
            assert.deepEqual(config.rejectnewfile, undefined);
            assert.deepEqual(config.rejectnewmsg, 'Currently, this bot is not accepting games, try again later');
        });

        it('export rejectnewmsg custom message if used', () => {
            argv.rejectnewmsg = 'Sorry, i am not available now.';

            config.updateFromArgv(argv);

            assert.deepEqual(config.rejectnew, undefined);
            assert.deepEqual(config.rejectnewfile, undefined);
            assert.deepEqual(config.rejectnewmsg, 'Sorry, i am not available now.');
        });

        it('do not throw error if both rejectnew and rejectnewmsg are used at the same time', () => {
            argv.rejectnew = true;

            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

        it('do not throw error if both rejectnewfile and rejectnewmsg are used at the same time', () => {
            argv.rejectnewfile = true;

            assert.doesNotThrow(function() { config.updateFromArgv(argv); }, Error);
        });

        it('throw error if both rejectnew and rejectnewfile are used at the same time', () => {
            argv.rejectnew = true;
            argv.rejectnewfile = true;

            assert.throws(function() { config.updateFromArgv(argv); }, Error);
        });

        it('export hidden if rejectnew is used', () => {
            argv.rejectnew = true;

            config.updateFromArgv(argv);

            assert.deepEqual(config.rejectnew, true);
            assert.deepEqual(config.hidden, true);
            assert.deepEqual(config.rejectnewfile, undefined);
            assert.deepEqual(config.rejectnewmsg, 'Currently, this bot is not accepting games, try again later');
        });

    });

    describe('Boardsizes', () => {

        let arrayExpected;
        let arrayExpectedDefault;

        beforeEach(function() {
            arrayExpected = [];

            arrayExpectedDefault = [];
            arrayExpectedDefault[9] = true;
            arrayExpectedDefault[13] = true;
            arrayExpectedDefault[19] = true;
        });

        // do not retest extensively ranked unranked defaults

        it('export general arg default if no arg is used', () => {
            config.updateFromArgv(argv);

            arrayExpected[9] = true;
            arrayExpected[13] = true;
            arrayExpected[19] = true;

            assert.deepEqual(config.boardsizes, "9,13,19"); // default is auto set
            assert.deepEqual(config.boardsizesranked, undefined);
            assert.deepEqual(config.boardsizesunranked, undefined);

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);
            
            assert.deepEqual(config.allowed_boardsizes, arrayExpected);
            assert.deepEqual(config.allowed_boardsizes_ranked, []);
            assert.deepEqual(config.allowed_boardsizes_unranked, []);
        });

        it('export general arg', () => {
            argv.boardsizes = "9,19";

            config.updateFromArgv(argv);

            arrayExpected[9] = true;
            arrayExpected[19] = true;

            assert.deepEqual(config.boardsizes, "9,19");
            assert.deepEqual(config.boardsizesranked, undefined);
            assert.deepEqual(config.boardsizesunranked, undefined);

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);
            
            assert.deepEqual(config.allowed_boardsizes, arrayExpected);
            assert.deepEqual(config.allowed_boardsizes_ranked, []);
            assert.deepEqual(config.allowed_boardsizes_unranked, []);
        });

        it('export ranked arg, auto set unranked default', () => {
            argv.boardsizesranked = "19";

            config.updateFromArgv(argv);

            arrayExpected[19] = true;

            assert.deepEqual(config.boardsizes, undefined);
            assert.deepEqual(config.boardsizesranked, "19");
            assert.deepEqual(config.boardsizesunranked, "9,13,19"); // default is auto set

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);

            assert.deepEqual(config.allowed_boardsizes, []);
            assert.deepEqual(config.allowed_boardsizes_ranked, arrayExpected);
            assert.deepEqual(config.allowed_boardsizes_unranked, arrayExpectedDefault);
        });

        it('export unranked arg, auto set ranked default', () => {
            argv.boardsizesunranked = "9,19,25";

            config.updateFromArgv(argv);

            arrayExpected[9] = true;
            arrayExpected[19] = true;
            arrayExpected[25] = true;

            assert.deepEqual(config.boardsizes, undefined);
            assert.deepEqual(config.boardsizesranked, "9,13,19"); // default is auto set
            assert.deepEqual(config.boardsizesunranked, "9,19,25");

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);

            assert.deepEqual(config.allowed_boardsizes, []);
            assert.deepEqual(config.allowed_boardsizes_ranked, arrayExpectedDefault);
            assert.deepEqual(config.allowed_boardsizes_unranked, arrayExpected);
        });

        it('export general arg -all- if used', () => {
            argv.boardsizes = "all";

            config.updateFromArgv(argv);

            assert.deepEqual(config.boardsizes, "all");
            assert.deepEqual(config.boardsizesranked, undefined);
            assert.deepEqual(config.boardsizesunranked, undefined);

            assert.deepEqual(config.allow_all_boardsizes, true);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);

            assert.deepEqual(config.allowed_boardsizes, []);
            assert.deepEqual(config.allowed_boardsizes_ranked, []);
            assert.deepEqual(config.allowed_boardsizes_unranked, []);

        });

        it('export ranked arg -all- if used, auto set unranked default', () => {
            argv.boardsizesranked = "all";

            config.updateFromArgv(argv);

            assert.deepEqual(config.boardsizes, undefined);
            assert.deepEqual(config.boardsizesranked, "all");
            assert.deepEqual(config.boardsizesunranked, "9,13,19"); // default is auto set

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, true);
            assert.deepEqual(config.allow_all_boardsizes_unranked, false);

            assert.deepEqual(config.allowed_boardsizes, []);
            assert.deepEqual(config.allowed_boardsizes_ranked, []);
            assert.deepEqual(config.allowed_boardsizes_unranked, arrayExpectedDefault);

        });

        it('export unranked arg -all- if used, auto set ranked default', () => {
            argv.boardsizesunranked = "all";

            config.updateFromArgv(argv);

            assert.deepEqual(config.boardsizes, undefined);
            assert.deepEqual(config.boardsizesranked, "9,13,19"); // default is auto set
            assert.deepEqual(config.boardsizesunranked, "all");

            assert.deepEqual(config.allow_all_boardsizes, false);
            assert.deepEqual(config.allow_all_boardsizes_ranked, false);
            assert.deepEqual(config.allow_all_boardsizes_unranked, true);


            assert.deepEqual(config.allowed_boardsizes, []);
            assert.deepEqual(config.allowed_boardsizes_ranked, arrayExpectedDefault);
            assert.deepEqual(config.allowed_boardsizes_unranked, []);

        });

    });

});
